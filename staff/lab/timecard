#!/usr/bin/env python3
import argparse
import collections
import datetime

import matplotlib.pyplot as plt
from ocflib.lab import stats


NAME_MAX = 255


def generate_image(usage, users, dest, start, end):
    def adjusted_hour(hour):
        """Converts a 0-23 hour format into a 1-12 hour format"""
        if hour == 0 or hour == 12:
            return 12
        else:
            return hour % 12

    def pm_or_am(hour):
        return 'am' if hour <= 11 else 'pm'

    hours = ['{}{}'.format(adjusted_hour(hour), pm_or_am(hour)) for hour in range(24)]
    sums = [sum(usage[h]) for h in range(24)]

    plt.switch_backend('agg')
    fig = plt.figure()
    fig.set_size_inches(12, 4)

    plt.bar(range(24), sums, color='b')
    plt.xlim(0, 24)
    plt.xticks(range(24), hours, fontsize=8)
    plt.xlabel('Hour')
    plt.ylabel('# Times Present')
    plt.ylim(0, max(sums) * 1.15)

    plt.title('OCF Lab Timecard for {} ({} to {})'.format(
        ', '.join(users),
        start.strftime('%Y-%m-%d'),
        end.strftime('%Y-%m-%d')
    ))
    plt.savefig(dest, bbox_inches='tight')


def get_usage_count(*users, start=None, end=None):
    sem_start, sem_end = stats.semester_dates()
    if start is None:
        start = datetime.datetime.combine(sem_start, datetime.time())
    if end is None:
        end = datetime.datetime.combine(sem_end, datetime.time())

    step = datetime.timedelta(minutes=60)
    hours = collections.defaultdict(lambda: [0 for _ in range(7)])

    cnx = stats.get_connection()
    cursor = cnx.cursor()

    query = """
        SELECT `start`, `end`
        FROM `staff_session_duration_public`
        WHERE `user` IN %s
            AND `start` >= %s
            AND `end` <= %s
            AND `duration` IS NOT NULL
        ORDER BY start ASC"""
    cursor.execute(query, (users, start, end))
    logins = cursor.fetchall()

    was_logged_in = dict()
    for session in logins:
        start_time = session['start'].replace(microsecond=0, second=0, minute=0)
        end_time = session['end']
        while start_time <= end_time:
            was_logged_in[start_time] = True
            start_time += step

    time = start
    while time <= end:
        if was_logged_in.get(time):
            hours[time.hour][time.weekday()] += 1
        time += step

    return hours, start, end


def valid_date(s):
    # https://stackoverflow.com/a/25470943/6587177
    try:
        return datetime.datetime.strptime(s, '%Y-%m-%d')
    except ValueError:
        msg = "Not a valid date: '{0}'. Use an isoformat string (YYYY-mm-dd)".format(s)
        raise argparse.ArgumentTypeError(msg)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Generate timecard graphs')
    parser.add_argument('users', type=str, nargs='+', help='User to generate graph for')
    parser.add_argument('--dest', type=str, default='',
                        help='File to save graph in')
    parser.add_argument('--start', type=valid_date, default=None,
                        help='Start date for chart (in form YYYY-mm-dd; defaults to semester start')
    parser.add_argument('--end', type=valid_date, default=None,
                        help='End date for chart (in form YYYY-mm-dd; defaults to semester end')
    args = parser.parse_args()

    if args.dest:
        dest = args.dest
    else:
        # set name equal to a string of all users separated by underscores.
        # limit the string to be at max NAME_MAX (-4 to account for '.png')
        dest = '{}.png'.format('_'.join(sorted(args.users))[:NAME_MAX - 4])

    usage, start, end = get_usage_count(*args.users, start=args.start, end=args.end)
    generate_image(usage, args.users, dest, start, end)
